import pandas as pd
import redshift_connector
import seaborn as sns
import matplotlib.pyplot as plt
import streamlit as st
import matplotlib.ticker as ticker
import squarify
import os
import re
from datetime import datetime
from glob import glob
import plotly.express as px
import pycountry
import psycopg2
import psycopg2.extras

st.set_page_config(layout="wide") 

def line_chart_streamlit_plotly(data, x, y, title="Line Chart", x_label=None, y_label=None, smooth=False, window=3):
    df = data.copy()

    # Apply smoothing if enabled
    if smooth:
        df[y] = df[y].rolling(window=window, center=True).mean()

    fig = px.line(df, x=x, y=y)
    fig.update_layout(
        xaxis_title=x_label if x_label else x,
        yaxis_title=y_label if y_label else y,
        template="plotly_white",
        margin=dict(l=20, r=20, t=40, b=20)
    )
    st.plotly_chart(fig, use_container_width=True)

def plot_vertical_barchart_from_df(df, x_column, y_column, bar_width=0.6, figsize=(12, 8), font_size=14):
    # Filter out rows where y_column is 0 or NaN
    df = df[df[y_column].fillna(0) != 0]

    if df.empty:
        st.warning("No data to display in the chart.")
        return None

    # df_sorted = df.sort_values(by=y_column, ascending=False)
    xdata = df[x_column].astype(str)
    ydata = df[y_column]

    min_val = ydata.min()
    max_val = ydata.max()

    fig, ax = plt.subplots(figsize=figsize)
    fig.patch.set_facecolor("#0e1117")
    ax.set_facecolor("#0e1117")

    bars = ax.bar(xdata, ydata, width=bar_width, color="crimson")

    for bar in bars:
        height = bar.get_height()
        label = f"{height:,.0f}"

        if height > max_val * 0.1:
            ax.text(bar.get_x() + bar.get_width() / 2, height - (max_val * 0.01),
                    label, ha='center', va='top', color='white', fontsize=font_size-2)
        else:
            ax.text(bar.get_x() + bar.get_width() / 2, height + (max_val * 0.01),
                    label, ha='center', va='bottom', color='white', fontsize=font_size-2)

    ax.set_ylabel(y_column, fontsize=font_size, color='white')
    ax.set_xlabel(x_column, fontsize=font_size, color='white')
    ax.tick_params(axis='both', labelsize=font_size - 2, colors='white')

    # Set y-axis limits using actual min and max
    ax.set_ylim(min_val * 0.95 if min_val > 0 else min_val - 1, max_val * 1.05)

    for spine in ax.spines.values():
        spine.set_visible(False)

    return fig  

market_df = pd.read_csv('pages/advertising.csv', delimiter=",", on_bad_lines='skip')

market_df["Timestamp"] = pd.to_datetime(market_df["Timestamp"]).dt.date
market_df["Gender"] = market_df["Male"].replace({1: "Male", 0: "Female"})

Country_types = list(market_df["Country"].unique())
genders = list(market_df["Gender"].unique())
min_date = market_df['Timestamp'].min()
max_date = market_df['Timestamp'].max()

st.sidebar.header("Filter Options")
selected_country = st.sidebar.multiselect("Select Countries", Country_types, default=Country_types)
selected_gender = st.sidebar.multiselect("Select Genders ", genders, default=genders)
selected_dates = st.sidebar.date_input("Pick a date range", (min_date, max_date))

if len(selected_dates) == 2:
    start_date, end_date = selected_dates
    market_df_selected = market_df[
        market_df["Country"].isin(selected_country) &
        market_df["Gender"].isin(selected_gender) &
        (market_df["Timestamp"] >= start_date) &
        (market_df["Timestamp"] <= end_date)
    ]
else:
    st.warning("Please select a valid date range.")


col1, col2 = st.columns([1, 4])  # Adjust the ratio to your layout

with col1:
    st.image("pages/diginergyconsulting_logo.jpeg") 

with col2:
    st.markdown(
        "<h1 style='margin-top: 40px; font-size: 60px;'>Diginergy</h1>",
        unsafe_allow_html=True
    )

st.markdown(
        "<br><br>",
        unsafe_allow_html=True)

st.header("Marketing", divider="gray")


col = st.columns((2, 4), gap='medium')

with col[1]:
    st.subheader("Metric KPIs", divider="gray")
    total_people = market_df_selected.shape[0]
    total_clicked = market_df_selected[market_df_selected["Clicked on Ad"] == 1].shape[0]
    total_time = market_df_selected['Daily Time Spent on Site'].mean()
    st.metric(label="Total Beverages Sold", value=total_people, delta= 15)
    st.metric(label="Total Revenue", value=total_clicked, delta= 1234)
    st.metric(label="Average Price Sold", value=round(total_time,2), delta= 0.4)
